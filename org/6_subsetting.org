#+TITLE: VECTORS in R: Subsetting
#+AUTHOR: Introduction to data science (DSC 105) Fall 2022
#+startup: hideblocks indent overview inlineimages entitiespretty
#+PROPERTY: header-args:R :results output :session *R*
#+attr_html: :width 600px
[[../img/6_seoul.jpg]]

Subsetting and extracting relates to vectorization:
- How to get to parts of a vector
- How to control the indexing
- How to rescale vectors
- How to create matrices and arrays
- How to mix different data types

* Preparations to code along
#+attr_html: :width 400px
[[../img/emacsprep.png]]

- Open a new Org-mode file ~subsetting.org~ in Emacs (unless you prefer
  to work in your former ~vectors.org~ file

- Put this line at the top of the file ~subsetting.org~

  ~#+PROPERTY: header-args:R :results output :session *R*~

- Activate the code by putting your cursor on the line and entering
  ~C-c C-c~. You should see the message ~Local setup has been refreshed~
  in the minibuffer at the bottom of the editor.

- When you execute your first R code block, you'll be asked where you
  want the session named ~*R*~ to run: enter the path to ~subsetting.org~

- For plots, use the header ~:results graphics file :file subsetting.png~
  (this will overwrite the PNG file every time you create a new plot)

- When you leave Emacs, you'll be warned that the session ~*R*~ is
  active: you can ignore this warning

Subsetting and extracting relates to vectorization:
- How to get to parts of a vector
- How to control the indexing
- How to rescale vectors
- How to create matrices and arrays
- How to mix different data types

* Vectorization 1-2-3

- In R, you don't need loops to perform operations on all elements of
  a vector - this ability is called /vectorization/.

- There are three forms of vectorization in ~R~:

  1) An operator or a function acts on each element of a vector
     without you having to explicitly write a loop (it's also much
     faster in terms of execution):
     #+begin_src R
       foo <- c(1, -1, 4, 4, 0, 59, 3) # sample vector
       foo + 3    # add a number to the vector
       foo/3.2    # divide vector by number
       bar <- foo[-c(4:length(foo))]   # delete part of a vector
       rep(x=bar, times=2)    # repeat a vector
       exp(pi*1i) + 1  # Euler's formula - a complex number
       class(exp(pi*1i) + 1)  
       prod(c(1,2,3,4,5))  # 5!
       sapply(X=c(5),FUN=factorial) # apply FUN to X
     #+end_src

  2) A function takes a vector as input and calculates a summary
     statistic:
     #+begin_src R
       sum(1:5) # sum over all elements
       mean(1:5) # average over all elements
       summary(1:5) # 5-point statistical summary
     #+end_src

  3) A function calculates a summary statistic from several of its
     input arguments - this does not always work:
     #+begin_src R
       sum(1,2,3,4,5)  # OK
       mean(1,2) # not OK
       mean(c(1,2)) # OK
     #+end_src

* Subsetting: retrieving vector elements

We're working with the pre-loaded ~Nile~ data set.

- Print ~Nile~. *What do the numbers at the beginning of each row mean?*
  (And how can you verify this?)
  #+begin_src R
    Nile
  #+end_src

- Never investigate in the dark - always check data structure first:
  #+begin_src R
    str(Nile)
  #+end_src

  #+RESULTS:
  :  Time-Series [1:100] from 1871 to 1970: 1120 1160 963 1210 1160 1160 813 1230 1370 1140 ...

- Subsetting means retrieving a subset of vector elements. For
  "atomic" vectors (not part of a data frame or list as column
  vectors), you need to use the ~[ ]~ index operator.

- Which value are we retrieving with ~Nile[1]~?
  #+begin_src R
    Nile[1]
  #+end_src

  #+RESULTS:
  : [1] 1120

- What's the corresponding data science (not R) question?
  #+begin_quote
     What was the average flow through the Nile in 1871?
  #+end_quote

- To extract the time at which a time series was sampled, use ~time~,
  which is a function wrapper of the time series, and also a ~ts~ object
  #+begin_src R
    class(time(Nile))
    Nile[1]
    time(Nile)[1]
  #+end_src

  #+RESULTS:
  : [1] "ts"
  : [1] 1120
  : [1] 1871
  : [1] 1871 1872

- What is the value of the last element of ~Nile~?
  #+begin_src R
    Nile[length(Nile)]
  #+end_src

  #+RESULTS:
  : [1] 740

- What's the corresponding question?
  #+begin_quote
    What was the flow through the river Nile in the year
    ~time(Nile)[length(Nile)]~?
  #+end_quote

  #+begin_src R
    time(Nile)[length(Nile)]
  #+end_src

  #+RESULTS:
  : [1] 1970
  
* Using the colon operator in index

- Create a sample vector ~foo~
  #+begin_src R
    foo <- c(-1,3.0,4,67,330,-3) # assign vector to foo
    foo
  #+end_src

  #+RESULTS:
  : [1]  -1   3   4  67 330  -3

- You can now use ~:~ to extract any interval of indices
  #+begin_src R
    bar <- foo[2:5]
    bar
  #+end_src

  #+RESULTS:
  : [1]   3   4  67 330

- [ ] Careful with sequences!  Check this: is ~foo[n]:foo[m]==foo[n:m]~ ?
  #+begin_src R
    foo # original vector
    bar # subset of indices 2:5
    baz <- foo[2]:foo[5] # vector built using indices 2 and 5
    identical(bar,baz)  # are bar and baz the same?
    all.equal(bar,baz)  # are they near equal at last?
  #+end_src 

* Statistical functions work on subsets

- [ ] What is the average (~mean~) of the elements 2 to 5 in ~foo~?
  #+begin_src R
    foo[2:5]
    mean(foo[2:5])
    mean(foo)
  #+end_src

- [ ] What is the ~sum~ of the elements 2 to 5 in ~foo~?
  #+begin_src R
    foo
    sum(foo[2:5])
    sum(foo)
  #+end_src

- [ ] What is the statistical ~summary~ of the elements 2 to 5 in ~foo~?
  #+begin_src R
    foo
    summary(foo[2:5])
    summary(foo)
  #+end_src


* TODO Logical functions in vectors

* TODO Selecting with logical index/flag vectors

* TODO Practice with ~Nile~


* TODO Negative indices


* TODO Putting dissected vectors back together


* TODO Defining and using index vectors


* TODO Overwriting subvectors


* TODO Practice: subsetting (home assignment)


