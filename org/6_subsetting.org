* Subsetting
  [[https://www.youtube.com/playlist?list=PL6SfZh1-kWXlA2axuHdNMzhwhuEhtGtlK][Watch YouTube Playlist]]
  -----
** Vectorization 1-2-3
   # Source: Cotton p.13ff
   If you'd use a programming language like ~C~ or ~FORTRAN~, which is
   at its heart not interactive but procedural, or even ~Python~,
   which can be used interactively (via a console), you'd have to
   write a loop to perform an operation on all the elements of a
   vector. Not so in ~R~.

   There are three forms of vectorization in ~R~:

   1) An operator or a function acts on each element of a vector
      without you having to explicitly write a loop (it's also much
      faster in terms of execution):
      #+begin_example vectorization 1
      > foo <- c(1, -1, 4, 4, 0, 59, 3)

      > foo + 3               # add a number to the vector
      [1]  4  2  7  7  3 62  6

      > foo/3.2               # divide vector by number
      [1]  0.3125 -0.3125  1.2500  1.2500  0.0000 18.4375  0.9375

      > bar <- foo[-c(4:length(foo))]  # delete part of a vector
      [1]  1 -1  4

      > rep(x=bar, times=2)    # repeat a vector
      [1]  1 -1  4  1 -1  4

      > exp(pi*1i)+1  # Euler's formula
      [1] 0+1.224647e-16i

      > prod(c(1,2,3,4,5))
      [1] 120
      #+end_example
   2) A function takes a vector as input and calculates a summary
      statistic:
      #+begin_example
      > 1:5
      [1] 1 2 3 4 5
      > sum(1:5)
      [1] 15
      > mean(1:5)
      [1] 3
      #+end_example
   3) A function calculates a summary statistic from several of its
      input arguments - does not always work:
      #+begin_example
      > sum(1,2,3,4,5)  # OK
      [1] 15
      > mean(1,2) # not OK
      [1] 1
      > mean(c(1,2)) # OK
      [1] 1.5
      #+end_example

   Where does this leave us?
   * How to get to parts of a vector
   * How to control the indexing
   * How to rescale vectors
   * How to create matrices and arrays
   * How to mix different data types
** The row labels, like ~[1]~, correspond to the *index*
   #+begin_example
   > Nile
   Time Series:
   Start = 1871
   End = 1970
   Frequency = 1
   [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020
   [16]  960 1180  799  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840
   [31]  874  694  940  833  701  916  692 1020 1050  969  831  726  456  824  702
   [46] 1120 1100  832  764  821  768  845  864  862  698  845  744  796 1040  759
   [61]  781  865  845  944  984  897  822 1010  771  676  649  846  812  742  801
   [76] 1040  860  874  848  890  744  749  838 1050  918  986  797  923  975  815
   [91] 1020  906  901 1170  912  746  919  718  714  740
    #+end_example
** Subsetting: retrieving vector elements
   #+begin_example
   > Nile [1]
   [1] 1120
   > Nile[length(Nile)]
   [1] 740
   #+end_example
** Using colon operator in index
   #+begin_example USING COLON OPERATOR IN INDEX
   > foo <- c(-1,3.0,4,67,330,-3) # assign vector to foo
   > foo
   [1]  -1   3   4  67 330  -3

   > bar <- foo[2:5]  # assign subset of foo to bar
   > bar
   [1]   3   4  67 330
   #+end_example
** Careful with sequences: is ~foo[n]:foo[m]==foo[n:m]~?
   #+begin_example CAREFUL WITH SEQUENCES
   > bar <- foo[2:5]   # assign a subset of foo to bar
   > bar
   [1]   3   4  67 330

   > baz <- foo[2]:foo[5]  # asign a sequence to baz
   >
   > bar <- foo[2:5]; bar
   [1]   3   4  67 330

   > identical(bar,baz)  # are bar and baz identical?
   [1] FALSE
   >
   > all.equal(bar,baz)  # are they near equal at least?
   [1] "Numeric: lengths (4, 328) differ"
   #+end_example

** Stats functions work on any vector subset: ~mean~, ~sum~,
   #+begin_example
   > mean(foo[2:5])
   [1] 101

   > sum(foo)
   [1] 400

   > summary(foo)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
   -3.00    0.00    3.50   66.67   51.25  330.00
   #+end_example
** Logical functions in vectors: ~<~, ~>~, ~!=~, ~==~
   #+begin_example
   > foo <- c(-1, 3, 4, 5, 67, 330, -3, -99, 0, 0, 44)
   > foo_pos <- c(foo > 0)
   > foo_neg <- c(foo < 0)
   > foo_nul <- c(foo == 0)  # Why not = instead of ==?

   > c(foo=0)
   foo
   0

   > foo_pos
   [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE

   > foo_neg
   [1]  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE

   > foo_nul
   [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE

   > sum(foo_pos)   # What do you expect here (vector is LOGICAL)?
   [1] 6
   > sum(foo_neg)
   [1] 3
   > sum(foo_nul)
   [1] 2
   #+end_example

** Selecting with logical index vectors
   #+begin_example
   > foo[foo_pos]
   [1]   3   4   5  67 330  44

   > foo[foo_neg]
   [1]  -1  -3 -99

   > foo[foo_nul]
   [1] 0 0
   #+end_example
** Exercise with ~Nile~
   1. How many entries does the time series vector ~Nile~ have?
      #+begin_example
      > length(Nile)
      [1] 100
      #+end_example
   2. What is its last element?
      #+begin_example 740
      > tail(Nile)
      [1] 912 746 919 718 714 740
      > Nile[length(Nile)]
      [1] 740
      > Nile[100]
      [1] 740
      > Nile
      #+end_example
   3. What is the third to last element of ~Nile~?
      #+begin_example
      > Nile[length(Nile)-3]
      [1] 919
      #+end_example
   4. What is the average flow of the Nile between 1909-1969?
      #+begin_example
      > 1909-1871
      [1] 38
      > 1969-1871
      [1] 98
      > mean(Nile[(1909-1871):(1969-1871)])
      [1] 860.3279
      #+end_example
   5. How many values are below, how many above the mean
      value?
      #+begin_example ~Nile~ values below and above the mean
      > nile_pos <- c(Nile > mean(Nile))  # logical vector of values greater mean
      > nile_pos
      [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
      [13]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
      [25]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
      [37] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE
      [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
      [61] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
      [73] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
      [85] FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE
      [97] FALSE FALSE FALSE FALSE

      > nile_neg <- c(Nile < mean(Nile)) # logical vector of values smaller than mean
      > nile_neg
      [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
      [13] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
      [25] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
      [37]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE
      [49]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE
      [61]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE
      [73]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE
      [85]  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE
      [97]  TRUE  TRUE  TRUE  TRUE

      > sum(nile_pos)
      [1] 43
      > sum(nile_neg)
      [1] 57
      #+end_example
   6. How much water flowed down the Nile between 1871 and 1970?
      #+begin_example
      > sum(Nile)
      [1] 91935
      #+end_example
** Negative indices - removes elements (only output, no overwrite)
   #+begin_example
   > foo[foo_len]
   [1] 44

   > foo[-1]
   [1]  3   4   5  67 330  -3 -99   0   0  44

   > foo[-foo_len]
   [1] -1   3   4   5  67 330  -3 -99   0   0

   > foo   # foo is not changed (not overwritten)
   [1]  -1   3   4   5  67 330  -3 -99   0   0  44

   > foo[-c(1,3)]   # remove elements 1 and 3 from foo
   [1]   3   5  67 330  -3 -99   0   0  44

   > foo[-(1:2)]    # remove elements 1 and 2 from foo
   [1]   4   5  67 330  -3 -99   0   0  44
   #+end_example

   * Exercise: fixing wrong entries?
     #+begin_example
     myvec <- c(5,-2,3,4,4,4,6,8,10,40221,-8)
     > myvec
     [1] 5 -2 3 4  4  4  6  8  10  40221  -8
     # I want 5 -2.3 4 4 4 6 8 10 40221 -8

     > myvec[2] <- -2.3     # change second element
     > myvec[-3]            # does NOT change myvec!
     > myvec <- myvec[-3]   # delete third element
     > myvec
     [1] 5.0 -2.3  4.0  4.0  4.0  6.0  8.0  10.0  40221.0  -8.0
     #+end_example

** Putting dissected vectors back together
   #+begin_example
   > myvec <- c(5,-2.3,4,4,4,6,8,10,40221,-8)  # assigning vector to myvec
   > myvec
   [1]     5.0    -2.3     4.0     4.0     4.0     6.0     8.0    10.0 40221.0
   [10]    -8.0

   > myvec.len <- length(x=myvec)   # storing length of myvec in myvec.len
   > myvec.len
   [1] 10

   > bar <- myvec[myvec.len-1]   # storing next-to-last entry of myvec in bar
   > bar
   [1] 40221

   > qux <- myvec[-(myvec.len-1)]   # qux is myvec without the next-to-last element
   > qux
   [1]  5.0 -2.3  4.0  4.0  4.0  6.0  8.0 10.0 -8.0

   ## how can we put myvec from qux and bar back together?
   ## 1. remove last element of qux
   ## 2. add bar at the end
   ## 3. put last element of qux back

   > c(qux[-length(x=qux)], bar, qux[length(x=qux)])
   [1]     5.0    -2.3     4.0     4.0     4.0     6.0     8.0    10.0 40221.0
   [10]    -8.0

   > identical(myvec,c(qux[-length(x=qux)], bar, qux[length(x=qux)]))
   [1] TRUE
   #+end_example
** Defining and using vectors of indices
   #+begin_example
   > foo <- myvec[1:4]  # foo is a subset of myvec
   > foo
   [1]  5.0 -2.3  4.0  4.0

   > indexes <- c(4, rep(x=2, times=3),1,1,2,3:1)
   > indexes
   [1] 4 2 2 2 1 1 2 3 2 1

   > foo[indexes]   # indexes uses foo to create a new vector
   [1]  4.0 -2.3 -2.3 -2.3  5.0  5.0 -2.3  4.0 -2.3  5.0

   > indexes_bad <- c(1,-1)   # this is not allowed
   > foo[indexes_bad]
   Error in foo[indexes_bad] :
   only 0's may be mixed with negative subscripts
   #+end_example
** Overwriting a subvector with another vector
   #+begin_example
   > bar <- c(3,2,4,4,1,2,4,1,0,0,5)
   > bar
   [1] 3 2 4 4 1 2 4 1 0 0 5
   > length(bar)
   [1] 11
   > bar[1] <- 6  # replace first entry in bar
   > bar
   [1] 6 2 4 4 1 2 4 1 0 0 5
   > bar[c(2,4,6)] <- c(-2,0.5,-1) # same length vectors!
   > bar
   [1]  6.0 -2.0  4.0  0.5  1.0 -1.0  4.0  1.0  0.0  0.0  5.0
   > bar[7:10] <- 100  # overwrite indices 7 to 10 with 100
   > bar
   [1]   6.0  -2.0   4.0   0.5   1.0  -1.0 100.0 100.0 100.0 100.0   5.0
   #+end_example
   # ** Exercises only
   #    1) Create and store a vector that contains the following, in this
   #       order:
   #       - A sequence of length ~5~ from ~3~ to ~6~ (inclusive)
   #       - A twofold repetition of the vector ~c(2,-5.1,-33)~
   #       - The value $\frac{7}{42}+2$
   #    2) Extract the first and last elements of your vector in (1), and
   #       store them as a new object.
   #    3) Store as a third object the values returned by omitting the
   #       first and last values of your vector in (1).
   #    4) Use only (2) and (3) to reconstruct (1).
   #    5) Overwrite (1) with the same values sorted from smallest
   #       to largest.
   #    6) Use the colon operator as an index vector to reverse the order
   #       of (5), and confirm this is identical to using ~sort~ on (5)
   #       with ~decreasing=TRUE~.
   #    7) Create a vector from (3) that repeats the third element of (3)
   #       three times, the sixth element four times, and the last element
   #       once.
   #    8) Create a new vector as a copy of (5) as to a newly named
   #       object. Using this new copy of (5), overwrite the first, the
   #       fifth to the seventh (inclusive), and the last element with the
   #       values ~99~ to ~95~ (inclusive), respectively.

   #    (Source: Davies, 2016, p. 32)
** Exercises and Solutions
   #+begin_quote ex 1
   (1) Create and store a vector that contains the following, in this
   order:
   - A sequence of length ~5~ from ~3~ to ~6~ (inclusive)
   - A twofold repetition of the vector ~c(2,-5.1,-33)~
   - The value $\frac{7}{42}+2$
   #+end_quote
   #+begin_example sol 1
   > foo <- c(seq(from=3, to=6, length.out=5), rep(x=c(2,-5.1,-33), times=2), 7/42+2)
   > foo
   [1]   3.000000   3.750000   4.500000   5.250000   6.000000   2.000000
   [7]  -5.100000 -33.000000   2.000000  -5.100000 -33.000000   2.166667
   #+end_example

   #+begin_quote ex 2
   (2) Extract the first and last elements of your vector in (1), and
   store them as a new object.
   #+end_quote
   #+begin_example sol 2
   > bar <- c(foo[1],foo[length(foo)])
   > bar <- foo[c(1,length(foo))]          # shorter solution
   > bar
   [1] 3.000000 2.166667
   #+end_example

   #+begin_quote ex 3
   (3) Store as a third object the values returned by omitting the
   first and last values of your vector in (1).
   #+end_quote
   #+begin_example sol 3
   > baz <- foo[-c(1,length(foo))]   # or: foo[c(-1,-length(foo))]
   [1]   3.75   4.50   5.25   6.00   2.00  -5.10 -33.00   2.00  -5.10 -33.00
   #+end_example

   #+begin_quote ex 4
   (4) Use only (2) and (3) to reconstruct (1).
   #+end_quote
   #+begin_example sol 4
   > foo  # reconstruct using only bar and baz
   [1]   3.000000   3.750000   4.500000   5.250000   6.000000   2.000000
   [7]  -5.100000 -33.000000   2.000000  -5.100000 -33.000000   2.166667

   > bar                  # contains the first and last element of foo
   [1] 3.000000 2.166667

   > baz                  # foo without bar
   [1]   3.75   4.50   5.25   6.00   2.00  -5.10 -33.00   2.00  -5.10 -33.00

   > c(bar[1],baz,bar[2])
   [1]   3.000000   3.750000   4.500000   5.250000   6.000000   2.000000
   [7]  -5.100000 -33.000000   2.000000  -5.100000 -33.000000   2.166667

   > identical(foo,c(bar[1],baz,bar[2]))    # check identity
   [1] TRUE
   #+end_example

   #+begin_quote ex 5
   (5) Overwrite (1) with the same values sorted from smallest
   to largest.
   #+end_quote
   #+begin_example ex 5
   > foo
   [1]   3.000000   3.750000   4.500000   5.250000   6.000000   2.000000
   [7]  -5.100000 -33.000000   2.000000  -5.100000 -33.000000   2.166667

   > foo <- sort(x=foo, decreasing=FALSE)  # from smallest to largest
   > foo
   [1] -33.000000 -33.000000  -5.100000  -5.100000   2.000000   2.000000
   [7]   2.166667   3.000000   3.750000   4.500000   5.250000   6.000000
   #+end_example

   #+begin_quote ex 6
   (6) Use the colon operator as an index vector to reverse the order
   of (5), and confirm this is identical to using ~sort~ on (5)
   with ~decreasing=TRUE~.
   #+end_quote
   #+begin_example sol 6
   > foo[length(foo):1]  # the index sequence is reversed
   [1]   6.000000   5.250000   4.500000   3.750000   3.000000   2.166667
   [7]   2.000000   2.000000  -5.100000  -5.100000 -33.000000 -33.000000

   > sort(x=foo, decreasing=TRUE)  # sort from largest to smallest
   [1]   6.000000   5.250000   4.500000   3.750000   3.000000   2.166667
   [7]   2.000000   2.000000  -5.100000  -5.100000 -33.000000 -33.000000

   > identical(foo[length(foo):1],sort(x=foo, decreasing=TRUE))
   [1] TRUE
   #+end_example

   #+begin_quote ex 7
   (7) Create a vector from (3) that repeats the third element of (3)
   three times, the sixth element four times, and the last element
   once.
   #+end_quote
   #+begin_example sol 7
   > baz[c(rep(x=3,times=3),rep(x=6,times=4),length(x=baz))]
   [1]   5.25   5.25   5.25  -5.10  -5.10  -5.10  -5.10 -33.00
   #+end_example

   #+begin_quote ex 8
   (8) Create a new vector as a copy of (5) as to a newly named
   object. Using this new copy of (5), overwrite the first, the
   fifth to the seventh (inclusive), and the last element with the
   values ~99~ to ~95~ (inclusive), respectively.
   #+end_quote
   #+begin_example sol 8
   > foo            # vector from (5)
   [1] -33.000000 -33.000000  -5.100000  -5.100000   2.000000   2.000000
   [7]   2.166667   3.000000   3.750000   4.500000   5.250000   6.000000

   > qux <- foo     # create copy
   > qux
   [1] -33.000000 -33.000000  -5.100000  -5.100000   2.000000   2.000000
   [7]   2.166667   3.000000   3.750000   4.500000   5.250000   6.000000

   > qux[c(1,5:7,length(qux))] <- 99:95  # overwrite indices with sequence
   > qux
   [1]  99.00 -33.00  -5.10  -5.10  98.00  97.00  96.00   3.00   3.75   4.50
   [11]   5.25  95.00
   #+end_example
   (Source: Davies, 2016, p. 32)
** Example: rescaling
   #  (cp. Davies p.107)
   In the example below, a vector of six values in increments of 1 is
   created. Then another vector is subtracted from it: the operation
   is carried out element-wise. The elements are matched up and the
   operation (subtraction) is carried out on each corresponding pair:
   #+begin_example
   > foo <- 5.5:0.5
   > foo
   [1]  5.5 4.5 3.5 2.5 1.5 0.5
   > foo-c(2,4,6,8,10,12)  # subtract another vector
   [1]   3.5   0.5  -2.5  -5.5  -8.5 -11.5
   #+end_example

   What if the vectors have different length?  Either the longer
   vector can be evenly divided by the shorter vector, or not.
   #+begin_example
   # Want to alternate entries of foo as positive and negative

   > foo * c(1,-1,1,-1,1,-1) # explicit multiplcation by element
   [1]  5.5 -4.5  3.5 -2.5  1.5 -0.5

   > bar <- c(1,-1) # multiply by even multiple
   > length(foo)
   [1] 6
   > length(bar)
   [1] 2
   > foo * bar
   [1]  5.5 -4.5  3.5 -2.5  1.5 -0.5

   > baz <- c(1, -1, 0.5, -0.5)
   > length(baz)
   [1] 4
   > foo*baz
   [1] 5.50 4.50 1.75 1.25 1.50 0.50
   Warning message:
   In foo * baz :
   longer object length is not a multiple of shorter object length
   #+end_example
   #+CAPTION: Element-wise operation on two vectors of differing lengths (Source: Davies, 2016)
   #+NAME: fig:vectors
   [[./img/vectors.png]]

   #+begin_example  vector-wise operators
   > foo
   [1] 5.5 4.5 3.5 2.5 1.5 0.5
   > qux <- 3

   > foo + qux
   [1] 8.5 7.5 6.5 5.5 4.5 3.5

   > foo + c(3,3,3,3,3,3)
   [1] 8.5 7.5 6.5 5.5 4.5 3.5

   > foo+rep(x=3,times=length(x=foo))
   [1] 8.5 7.5 6.5 5.5 4.5 3.5
   #+end_example

   #+begin_example element-wise overwriting
   > foo
   [1] 5.5 4.5 3.5 2.5 1.5 0.5

   > foo[c(1,3,5,6)] <- c(-99,99)
   > foo
   [1] -99.0   4.5  99.0   2.5 -99.0  99.0
   #+end_example
** Vector Recycling
   # Source: Cotton, 2013, p. 67
   #+begin_example
   > 1:5 + 1:6
   [1]  2  4  6  8 10  7
   Warning message:
   longer object length is not a multiple of shorter object length

   > 1:5 + 1:7
   [1]  2  4  6  8 10  7  9
   Warning message:
   longer object length is not a multiple of shorter object length
   #+end_example
** Class exercise: rescale from inches to cm
   *Problem: convert inches to cm ($1\,inch\equiv 2.54\, cm$):
   #+begin_example
   inches <- c(69, 62, 66, 70, 70, 73, 67, 73, 67, 70)
   #+end_example
   *Solution:*
   #+begin_example
   > cm <- inches * 2.54
   > cm
   [1] 175.26 157.48 167.64 177.80 177.80 185.42 170.18 185.42 170.18 177.80
   #+end_example
# ** Exercises
#    #+begin_quote
#    1) Convert the vector ~c(2,0.5,1,2,0.5,1,2,0.5,1)~ to a vector of
#    only ~1~s, using a vector of length $3$.
#    2) The conversion from a temperature measurement in degrees
#       Fahrenheit $F$ to Celsius $C$ is performed using the following
#       equation:
#       \begin{equation}
#       C = \frac{5}{9}\left( F-32\right)
#       \end{equation}
#       Use vector-oriented behavior in ~R~ to convert the temperatures
#       $45$, $77$, $20$, $19$, $101$, $120$, and $212$ in degrees
#       Fahrenheit to degrees Celsius.
#    3) Use the vector ~c(2,4,6)~ and the vector ~c(1,2)~ in conjunction
#       with ~rep~ and ~*~ to produce the vector ~c(2,4,6,4,8,12)~.
#    4) Overwrite the middle four elements of the resulting vector from
#       (3) with the two recycled values ~-0.1~ and ~-100~, in that
#       order.
#    #+end_quote
** Exercises & Solutions
   # (Davies, 2016, p. 36)
   #+begin_quote
   (1) Convert the vector ~c(2,0.5,1,2,0.5,1,2,0.5,1)~ to a vector of
   only ~1~s, using a vector of length $3$.
   #+end_quote
   #+begin_example
   > foo <- c(2,0.5,1,2,0.5,1,2,0.5,1)
   > bar <- c(2,0.5,1)
   > foo / bar
   [1] 1 1 1 1 1 1 1 1 1
   #+end_example
   #+begin_quote
   (2) The conversion from a temperature measurement in degrees
   Fahrenheit $F$ to Celsius $C$ is performed using the following
   equation:
   \begin{equation}
   C = \frac{5}{9}\left( F-32\right)
   \end{equation}
   Use vector-oriented behavior in ~R~ to convert the temperatures
   $45$, $77$, $20$, $19$, $101$, $120$, and $212$ in degrees
   Fahrenheit to degrees Celsius.
   #+end_quote
   #+begin_example
   > temp <- c(45, 77, 20, 19, 101, 120, 212)  # degrees Fahrenheit
   > temp
   [1]  45  77  20  19 101 120 212

   > temp_C <- 5/9 * (temp - 32)  # degrees Celsius
   > temp_C
   [1]   7.222222  25.000000  -6.666667  -7.222222  38.333333  48.888889 100.000000
   #+end_example
   #+begin_quote
   (3) Use the vector ~c(2,4,6)~ and the vector ~c(1,2)~ in conjunction
   with ~rep~ and ~*~ to produce the vector ~c(2,4,6,4,8,12)~.
   #+end_quote
   #+begin_example
   > rep(x=c(2,4,6),times=2)
   [1] 2 4 6 2 4 6

   > rep(x=c(1,2),each=3)
   [1] 1 1 1 2 2 2

   > rep(x=c(2,4,6),times=2)*rep(x=c(1,2),each=3)
   [1]  2  4  6  4  8 12
   #+end_example
   #+begin_quote
   (4) Overwrite the middle four elements of the resulting vector from
   (3) with the two recycled values ~-0.1~ and ~-100~, in that
   order.
   #+end_quote
   #+begin_example
   > foo <- rep(x=c(2,4,6),times=2)*rep(x=c(1,2),each=3)
   > foo
   [1]  2  4  6  4  8 12
   > foo[2:5] <- c(-0.1,-100)
   > foo
   [1]    2.0   -0.1 -100.0   -0.1 -100.0   12.0
   #+end_example
