#+TITLE: VECTORS in R: Subsetting
#+AUTHOR: Introduction to data science (DSC 105) Fall 2022
#+startup: hideblocks indent overview inlineimages entitiespretty
#+PROPERTY: header-args:R :results output :session *R*
#+attr_html: :width 600px
[[../img/extraction.png]]

Subsetting and extracting relates to vectorization:
- How to get to parts of a vector
- How to control the indexing
- How to rescale vectors
- How to create matrices and arrays
- How to mix different data types

* Preparations to code along
#+attr_html: :width 400px
[[../img/emacsprep.png]]

- Open a new Org-mode file ~subsetting.org~ in Emacs

- Put this line at the top of the file ~subsetting.org~

  ~#+PROPERTY: header-args:R :results output :session *R*~

- Activate the code by putting your cursor on the line and entering
  ~C-c C-c~. You should see the message ~Local setup has been refreshed~
  in the minibuffer at the bottom of the editor.

- When you execute your first R code block, you'll be asked where you
  want the session named ~*R*~ to run: enter the path to ~subsetting.org~

- For plots, use the header ~:results graphics file :file subsetting.png~
  (this will overwrite the PNG file every time you create a new plot)

- When you leave Emacs, you'll be warned that the session ~*R*~ is
  active: you can ignore this warning

* Vectorization 1-2-3

- In R, you don't need loops to perform operations on all elements of
  a vector - this ability is called /vectorization/.

- There are three forms of vectorization in ~R~:

  1) An operator or a function acts on each element of a vector
     without you having to explicitly write a loop (it's also much
     faster in terms of execution):
     #+begin_src R
       foo <- c(1, -1, 4, 4, 0, 59, 3) # sample vector
       foo + 3    # add a number to the vector
       foo/3.2    # divide vector by number
       bar <- foo[-c(4:length(foo))]   # delete part of a vector
       rep(x=bar, times=2)    # repeat a vector
       exp(pi*1i) + 1  # Euler's formula - a complex number
       class(exp(pi*1i) + 1)  
       prod(c(1,2,3,4,5))  # 5!
       sapply(X=c(5),FUN=factorial) # apply FUN to X
     #+end_src

  2) A function takes a vector as input and calculates a summary
     statistic:
     #+begin_src R
       sum(1:5) # sum over all elements
       mean(1:5) # average over all elements
       summary(1:5) # 5-point statistical summary
     #+end_src

  3) A function calculates a summary statistic from several of its
     input arguments - this does not always work:
     #+begin_src R
       sum(1,2,3,4,5)  # OK
       mean(1,2) # not OK
       mean(c(1,2)) # OK
     #+end_src

* Subsetting: retrieving vector elements

We're working with the pre-loaded ~Nile~ data set.

- Print ~Nile~. *What do the numbers at the beginning of each row mean?*
  (And how can you verify this?)
  #+begin_src R
    Nile
  #+end_src
- Never investigate in the dark - always check data structure first:
  #+begin_src R
    str(Nile)
  #+end_src
- Subsetting means retrieving a subset of vector elements. For
  "atomic" vectors (not part of a data frame or list as column
  vectors), you need to use the ~[ ]~ index operator.

- Print the first element of ~Nile~
  #+begin_src R
    Nile[1]
  #+end_src
- What's the corresponding data science (*not R*) question?
  #+begin_quote
     » What was the average flow through the Nile in 1871? «
  #+end_quote
- To extract the time at which a time series was sampled, use ~time~,
  which is a function wrapper of the time series, and also a ~ts~ object
  #+begin_src R
    class(time(Nile))
    Nile[1]
    time(Nile)[1]
  #+end_src
- What is the value of the last element of ~Nile~?
  #+begin_src R
    Nile[length(Nile)]
  #+end_src
- What's the corresponding question?
  #+begin_quote
    »What was the flow through the river Nile in the last year of
    observations?«
  #+end_quote
  
  #+begin_src R
    time(Nile)[length(Nile)]
  #+end_src
* Using the colon operator in index

- Create a sample vector ~foo~
  #+begin_src R
    foo <- c(-1,3.0,4,67,330,-3) # assign vector to foo
    foo
  #+end_src

  #+RESULTS:
  : [1]  -1   3   4  67 330  -3

- You can now use ~:~ to extract any interval of indices
  #+begin_src R
    bar <- foo[2:5]
    bar
  #+end_src

- [ ] Check using R: is ~foo[n]:foo[m]~ the same as ~foo[n:m]~
  #+begin_src R
    foo # original vector
    bar # subset of indices 2:5
    baz <- foo[2]:foo[5] # vector built using indices 2 and 5
    identical(bar,baz)  # are bar and baz the same?
    all.equal(bar,baz)  # are they near equal at last?
  #+end_src 
* Statistical functions work on subsets

- [ ] What is the average (~mean~) of the elements 2 to 5 in ~foo~?
  #+begin_src R
    foo[2:5]
    mean(foo[2:5])
    mean(foo)
  #+end_src
- [ ] What is the ~sum~ of the elements 2 to 5 in ~foo~?
  #+begin_src R
    foo
    sum(foo[2:5])
    sum(foo)
  #+end_src
- [ ] What is the statistical ~summary~ of the elements 2 to 5 in ~foo~?
  #+begin_src R
    foo
    summary(foo[2:5])
    summary(foo)
  #+end_src
* Logical functions in vectors: ~<~, ~>~, ~!=~, ~==~

- You can directly use logical operators to subset vectors
  
- Modify the sample vector ~foo~:  ~-1   3   4  67 330  -3~
  1) add a ~5~ between ~4~ and ~67~
  2) add ~-99 0 0 44~ at the end of the vector
  #+begin_src R
    foo <- c(-1,3.0,4,67,330,-3) # original vector
    foo <- c(foo[1:3],5,foo[4:length(foo)], c(-99,0,0,44))
    foo
  #+end_src

- If you messed up somewhere, reset your variables with ~rm(list=ls())~

- Create logical sub-vectors of positive and negative elements
  #+begin_src R
    foo_pos <- c(foo > 0)
    foo_pos
    foo_neg <- c(foo < 0)
    foo_neg
    foo_nul <- c(foo == 0)  # what is c(foo=0) ?
    foo_nul
  #+end_src
- What is ~c(foo = 0)~?
  #+begin_src R
    c(foo=0)    
  #+end_src
- What happens if you ~sum~ these vectors?
  #+begin_src R
    sum(foo_pos)
    sum(foo_neg)
    sum(foo_nul)
  #+end_src
* Selecting with logical index vectors

- You can now use these subvectors as logical flag or index vectors

- For example, to extract all /positive/ elements from ~foo~ 
  #+begin_src R
    foo[foo_pos]  # using an index vector
    foo[foo>0]    # using a logical operator
  #+end_src

- For example, to extract all /negative/ elements from ~foo~ 
  #+begin_src R
    foo[foo_neg]  # using an index vector
    foo[foo<0]    # using a logical operator
  #+end_src

  #+RESULTS:
  : [1]  -1  -3 -99
  : [1]  -1  -3 -99
 
- For example, to extract all 0 elements from ~foo~ 
  #+begin_src R
    foo[foo_nul]  # using an index vector
    foo[foo==0]    # using a logical operator
  #+end_src

  #+RESULTS:
  : [1] 0 0
  : [1] 0 0

- Why would you define logical flag vectors instead of using operators?
  #+begin_quote
    Because you can define and alter the index vector definition in
    ONE place, while you'd have to alter the logical operators in many
    places in a program.
  #+end_quote
* TODO Practice with ~Nile~
* TODO Negative indices
* TODO Putting dissected vectors back together
* TODO Defining and using index vectors
* TODO Overwriting subvectors
* TODO Practice: subsetting (home assignment)



